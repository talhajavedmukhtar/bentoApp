{"ast":null,"code":"var _jsxFileName = \"/Users/Talha/repos/steed/bento/bentoApp/src/worker.js\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst createField = (width, height) => {\n  const newField = Array.from({\n    length: height\n  }, () => Array.from({\n    length: width\n  }, () => '**'));\n  return newField;\n};\n\n// Function to convert a string to a color\nconst stringToColor = async string => {\n  const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(string));\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n\n  // Generate warm colors by focusing on the warm spectrum\n  const r = parseInt(hashHex.substring(0, 6), 16) % 256; // Red component\n  const g = parseInt(hashHex.substring(6, 12), 16) % 200; // Green component\n  const b = parseInt(hashHex.substring(12, 18), 16) % 100; // Blue component\n\n  return `rgb(${r}, ${g}, ${b})`;\n};\n\n// Function to visualize the field\nconst visualizeField = async (field, w, h) => {\n  const size = 10 / (w > h ? w : 2 * h);\n  const boxSize = `${size}em`;\n  const visualizedField = [];\n  for (let i = 0; i < field.length; i++) {\n    const row = [];\n    for (let j = 0; j < field[0].length; j++) {\n      const color = field[i][j] === '**' ? '#FFFCF0' : await stringToColor(field[i][j]);\n      row.push( /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          width: boxSize,\n          height: boxSize,\n          backgroundColor: color,\n          padding: boxSize,\n          marginRight: '0em',\n          border: '1px solid #282726',\n          display: 'inline-block'\n        }\n      }, `${i}-${j}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 34,\n        columnNumber: 9\n      }, this));\n    }\n    visualizedField.push( /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        lineHeight: '0em'\n      },\n      children: row\n    }, i, false, {\n      fileName: _jsxFileName,\n      lineNumber: 48,\n      columnNumber: 26\n    }, this));\n  }\n  return visualizedField;\n};\n\n// Create initial field when component mounts\nuseEffect(() => {\n  const initialField = createField(width, height);\n  visualizeField(initialField, width, height).then(visualized => setField(visualized));\n}, []);\nuseEffect(() => {\n  console.log(\"Processing changed: \", processing);\n}, [processing]);\nconst handleWidthChange = e => {\n  setWidth(parseInt(e.target.value));\n};\nconst handleHeightChange = e => {\n  setHeight(parseInt(e.target.value));\n};\nconst handleNumBoxesChange = e => {\n  setNumBoxes(parseInt(e.target.value));\n};\nconst handleMinSizeChange = e => {\n  setMinSize(parseInt(e.target.value));\n};\nconst handleMaxSizeChange = e => {\n  setMaxSize(parseInt(e.target.value));\n};\nfunction getBoxOptions(minSize, maxSize, width, height) {\n  const options = new Set();\n  for (let i = minSize; i <= maxSize; i++) {\n    for (let j = minSize; j <= maxSize; j++) {\n      if (j <= height && i <= width) {\n        options.add([i, j, i * j].toString());\n        options.add([j, i, i * j].toString());\n      }\n    }\n  }\n  return Array.from(options).sort((a, b) => b[2] - a[2]);\n}\nfunction findSequenceOfLength(number, numbers, length, boxOptions) {\n  /*const nums = [];\n   for (let i = 0; i < boxOptions.length; i++) {\n    const size = boxOptions[i].split(\",\")[2];\n     if (numbers.includes(size)) {\n      nums.push(size);\n    }\n  }*/\n\n  const nums = numbers;\n  shuffle(nums);\n  let foundSequence = [];\n  function dfs(target, path) {\n    if (target === 0 && path.length === length) {\n      foundSequence = [...path];\n      return;\n    }\n    for (const num of nums) {\n      if (num <= target) {\n        path.push(num);\n        dfs(target - num, path);\n        path.pop();\n      }\n    }\n  }\n  dfs(number, []);\n  return foundSequence;\n}\nfunction findSequenceOfLengthBest(number, numbers, length, boxOptions) {\n  const nums = [];\n  for (let i = 0; i < boxOptions.length; i++) {\n    const size = boxOptions[i].split(\",\")[2];\n    if (numbers.includes(size)) {\n      nums.push(size);\n    }\n  }\n  shuffle(nums);\n  console.log(\"Nums: \", nums);\n  const dp = Array.from({\n    length: length + 1\n  }, () => Array(number + 1).fill(null));\n  try {\n    dp[0][0] = [];\n  } catch (e) {\n    return [];\n  }\n  for (let i = 1; i <= length; i++) {\n    for (let j = 0; j <= number; j++) {\n      for (const num of nums) {\n        if (j - num >= 0 && dp[i - 1][j - num] !== null) {\n          if (dp[i][j] === null || dp[i][j].length < i) {\n            const nextSequence = dp[i - 1][j - num].concat([num]);\n            if (!hasRepetition(nextSequence) || i >= length * 0.8) {\n              dp[i][j] = nextSequence;\n            }\n          }\n        }\n      }\n    }\n  }\n  return dp[length][number] !== null ? dp[length][number] : [];\n}\nfunction generateSequence(targetSum, arr, length) {\n  const result = [];\n  function dfs(currentSum, path) {\n    if (currentSum === targetSum && path.length === length) {\n      result.push([...path]);\n      return;\n    }\n    for (let i = 0; i < arr.length; i++) {\n      if (currentSum + arr[i] <= targetSum) {\n        path.push(arr[i]);\n        dfs(currentSum + arr[i], path);\n        path.pop();\n      }\n    }\n  }\n  dfs(0, []);\n  return result;\n}\n\n// Check if there are repetitions in the sequence\nfunction hasRepetition(sequence) {\n  for (let i = 1; i < sequence.length; i++) {\n    if (sequence[i] === sequence[i - 1]) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Helper function to shuffle an array\nfunction shuffle(array) {\n  let currentIndex = array.length,\n    randomIndex;\n  while (currentIndex !== 0) {\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex--;\n    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];\n  }\n}\nfunction bentoIsFilledAppropriately(field, numBoxesSoFar, numBoxes) {\n  for (let row of field) {\n    for (let element of row) {\n      if (element === \"**\") {\n        return false;\n      }\n    }\n  }\n  console.log(\"Bento filled? \", numBoxesSoFar === numBoxes, numBoxesSoFar, numBoxes);\n  return numBoxesSoFar === numBoxes;\n}\nfunction storeForbiddenPath(forbiddenPathsDict, path, position, boxOption) {\n  if (forbiddenPathsDict[path]) {\n    if (!forbiddenPathsDict[path].includes(`${boxOption},${position}`)) {\n      forbiddenPathsDict[path].push(`${boxOption},${position}`);\n    }\n  } else {\n    forbiddenPathsDict[path] = [`${boxOption},${position}`];\n  }\n}\nfunction retrieveForbiddenPaths(forbiddenPathsDict, basePath) {\n  return forbiddenPathsDict[basePath] || [];\n}\nfunction getBoxOptionsFromSize(minSize, maxSize, size, width, height) {\n  const boxOptions = getBoxOptions(minSize, maxSize, width, height);\n  console.log(\"Box ops: \", boxOptions, \" size: \", size);\n  return boxOptions.filter(x => x.split(\",\")[2] === size);\n}\nfunction findCandidateIndices(field, boxOptionString) {\n  const boxOption = boxOptionString.split(\",\");\n  const boxWidth = parseInt(boxOption[0]);\n  const boxHeight = parseInt(boxOption[1]);\n  const indices = [];\n  const rows = field.length;\n  const cols = rows > 0 ? field[0].length : 0;\n  for (let i = 0; i < rows - boxHeight + 1; i++) {\n    for (let j = 0; j < cols - boxWidth + 1; j++) {\n      const subArr = field.slice(i, i + boxHeight).map(row => row.slice(j, j + boxWidth));\n      const isAllEmpty = subArr.every(row => row.every(elem => elem === \"**\"));\n      if (isAllEmpty) {\n        indices.push([i, j]);\n      }\n    }\n  }\n  return indices;\n}\nfunction augmentWithBox(field, index, boxOptionString, newChar) {\n  console.log(\"Augmentation time!!! \", index);\n  const fieldCopy = field.map(row => [...row]); // Deep copy of the field\n\n  const boxOption = boxOptionString.split(\",\");\n  const boxWidth = parseInt(boxOption[0]);\n  const boxHeight = parseInt(boxOption[1]);\n  const [x, y] = index;\n  for (let i = x; i < x + boxHeight; i++) {\n    for (let j = y; j < y + boxWidth; j++) {\n      console.log(\"Augmentation time!!!XXX\");\n      fieldCopy[i][j] = `*${newChar}`;\n    }\n  }\n  return fieldCopy;\n}\nonmessage = function (e) {\n  // Receive the data sent from the main thread\n  const {\n    width,\n    height,\n    numBoxes,\n    minSize,\n    maxSize\n  } = e.data;\n  let field = createField(width, height);\n  const boxOptions = getBoxOptions(minSize, maxSize, width, height);\n  const boxSizes = boxOptions.map(x => x.split(\",\")[2]);\n  console.log(\"Box options: \", boxOptions);\n  console.log(\"Box sizes: \", boxSizes);\n  let theSequence = findSequenceOfLengthBest(width * height, boxSizes, numBoxes, boxOptions);\n  //let theSequence = generateSequence(width * height, boxSizes, numBoxes);\n  //shuffle(theSequence);\n  theSequence.sort((a, b) => b - a);\n  setSequence(theSequence.toString());\n  let prevPrevState = _.cloneDeep(field);\n  let prevState = _.cloneDeep(field);\n  let prevPrevNumBoxes = 0;\n  let prevNumBoxes = 0;\n  const forbiddenPathsDict = {};\n  let runNumber = 0;\n  let numBoxesSoFar = 0;\n  let currentPath = [];\n  if (theSequence.length > 0) {\n    while (!bentoIsFilledAppropriately(field, numBoxesSoFar, numBoxes)) {\n      const relevantBoxSize = theSequence[numBoxesSoFar];\n      const relevantBoxOptions = getBoxOptionsFromSize(minSize, maxSize, relevantBoxSize, width, height);\n      let newBoxCanBeAdded = false;\n      let newBoxOption = null;\n      let newBoxIndex = null;\n      console.log(\"relevantBoxSize: \", relevantBoxSize);\n      console.log(\"relevantBoxOptions: \", relevantBoxOptions);\n      for (const boxOption of relevantBoxOptions) {\n        const candidateIndices = findCandidateIndices(field, boxOption);\n        //console.log(\"candidateIndices: \",candidateIndices);\n        const validCandidateIndices = [];\n        for (const candidateIndex of candidateIndices) {\n          const pathStr = `${candidateIndex},${boxOption}`;\n          if (!retrieveForbiddenPaths(forbiddenPathsDict, String(currentPath)).includes(pathStr)) {\n            //console.log(\"ValidCandidate: \",candidateIndex,boxOption)\n            validCandidateIndices.push(candidateIndex);\n          }\n        }\n        if (validCandidateIndices.length > 0) {\n          newBoxCanBeAdded = true;\n          newBoxOption = boxOption;\n          const randomIndex = Math.floor(Math.random() * validCandidateIndices.length);\n          console.log(\"vc length: \", validCandidateIndices.length);\n          console.log(\"randomIndex: \", randomIndex);\n          newBoxIndex = validCandidateIndices[randomIndex];\n          /*\n          if (validCandidateIndices.some(index => index[0] === 0 && index[1] === 0)) {\n            newBoxIndex = [0, 0];\n          } else {\n            newBoxIndex = validCandidateIndices[Math.floor(Math.random() * validCandidateIndices.length)];\n          }*/\n          break;\n        }\n      }\n      if (newBoxCanBeAdded) {\n        prevPrevNumBoxes = prevNumBoxes;\n        prevPrevState = _.cloneDeep(prevState);\n        prevNumBoxes = numBoxesSoFar;\n        prevState = _.cloneDeep(field);\n        const augmentedField = augmentWithBox(field, newBoxIndex, newBoxOption, numBoxesSoFar);\n        field = _.cloneDeep(augmentedField);\n        numBoxesSoFar++;\n        currentPath.push([newBoxOption, newBoxIndex]);\n      } else {\n        if (currentPath.length === 0) {\n          field = createField(width, height);\n          prevPrevNumBoxes = 0;\n          prevPrevState = _.cloneDeep(field);\n          prevNumBoxes = 0;\n          prevState = _.cloneDeep(field);\n          numBoxesSoFar = 0;\n        } else {\n          const [lastBoxPosition, lastBoxOption] = currentPath.pop();\n          storeForbiddenPath(forbiddenPathsDict, String(currentPath), lastBoxPosition, lastBoxOption);\n          if (currentPath.length === 0) {\n            field = createField(width, height);\n            prevPrevNumBoxes = 0;\n            prevPrevState = _.cloneDeep(field);\n            prevNumBoxes = 0;\n            prevState = _.cloneDeep(field);\n            numBoxesSoFar = 0;\n          } else {\n            numBoxesSoFar = prevNumBoxes;\n            field = _.cloneDeep(prevState);\n            prevNumBoxes = prevPrevNumBoxes;\n            prevState = _.cloneDeep(prevPrevState);\n          }\n        }\n      }\n      runNumber++;\n      if (runNumber % 1 === 0) {\n        console.log(runNumber, numBoxesSoFar);\n        console.log(\"path: \", currentPath);\n        console.log(\"numBoxesSoFar: \", numBoxesSoFar);\n      }\n      if (runNumber % 10 === 0) {\n        //visualizeField(field, width, height).then((visualized) => setField(visualized));\n      }\n      if (runNumber % 10000 === 0) {\n        break;\n      }\n      if (prevNumBoxes === prevPrevNumBoxes && prevNumBoxes === numBoxesSoFar) {\n        theSequence = findSequenceOfLengthBest(width * height, boxOptions.map(x => x.split(\",\")[2]), numBoxes, boxOptions);\n        //let theSequence = generateSequence(width * height, boxSizes, numBoxes);\n        theSequence.sort((a, b) => b - a);\n        setSequence(theSequence.toString());\n        field = createField(width, height);\n        prevPrevNumBoxes = 0;\n        prevPrevState = _.cloneDeep(field);\n        prevNumBoxes = 0;\n        prevState = _.cloneDeep(field);\n        numBoxesSoFar = 0;\n        currentPath = [];\n      }\n    }\n\n    //visualizeField(field, width, height).then((visualized) => setField(visualized));\n  }\n\n  // Post the result back to the main thread\n  postMessage(field);\n};","map":{"version":3,"names":["createField","width","height","newField","Array","from","length","stringToColor","string","hashBuffer","crypto","subtle","digest","TextEncoder","encode","hashArray","Uint8Array","hashHex","map","b","toString","padStart","join","r","parseInt","substring","g","visualizeField","field","w","h","size","boxSize","visualizedField","i","row","j","color","push","_jsxDEV","style","backgroundColor","padding","marginRight","border","display","fileName","_jsxFileName","lineNumber","columnNumber","lineHeight","children","useEffect","initialField","then","visualized","setField","console","log","processing","handleWidthChange","e","setWidth","target","value","handleHeightChange","setHeight","handleNumBoxesChange","setNumBoxes","handleMinSizeChange","setMinSize","handleMaxSizeChange","setMaxSize","getBoxOptions","minSize","maxSize","options","Set","add","sort","a","findSequenceOfLength","number","numbers","boxOptions","nums","shuffle","foundSequence","dfs","path","num","pop","findSequenceOfLengthBest","split","includes","dp","fill","nextSequence","concat","hasRepetition","generateSequence","targetSum","arr","result","currentSum","sequence","array","currentIndex","randomIndex","Math","floor","random","bentoIsFilledAppropriately","numBoxesSoFar","numBoxes","element","storeForbiddenPath","forbiddenPathsDict","position","boxOption","retrieveForbiddenPaths","basePath","getBoxOptionsFromSize","filter","x","findCandidateIndices","boxOptionString","boxWidth","boxHeight","indices","rows","cols","subArr","slice","isAllEmpty","every","elem","augmentWithBox","index","newChar","fieldCopy","y","onmessage","data","boxSizes","theSequence","setSequence","prevPrevState","_","cloneDeep","prevState","prevPrevNumBoxes","prevNumBoxes","runNumber","currentPath","relevantBoxSize","relevantBoxOptions","newBoxCanBeAdded","newBoxOption","newBoxIndex","candidateIndices","validCandidateIndices","candidateIndex","pathStr","String","augmentedField","lastBoxPosition","lastBoxOption","postMessage"],"sources":["/Users/Talha/repos/steed/bento/bentoApp/src/worker.js"],"sourcesContent":["const createField = (width, height) => {\n  const newField = Array.from({ length: height }, () =>\n    Array.from({ length: width }, () => '**')\n  );\n  return newField;\n};\n\n// Function to convert a string to a color\nconst stringToColor = async (string) => {\n  const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(string));\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');\n\n  // Generate warm colors by focusing on the warm spectrum\n  const r = parseInt(hashHex.substring(0, 6), 16) % 256; // Red component\n  const g = parseInt(hashHex.substring(6, 12), 16) % 200; // Green component\n  const b = parseInt(hashHex.substring(12, 18), 16) % 100; // Blue component\n\n  return `rgb(${r}, ${g}, ${b})`;\n};\n\n// Function to visualize the field\nconst visualizeField = async (field,w,h) => {\n  const size = 10 / (w > h ? w : 2*h);\n\n  const boxSize = `${size}em`\n\n  const visualizedField = [];\n  for (let i = 0; i < field.length; i++) {\n    const row = [];\n    for (let j = 0; j < field[0].length; j++) {\n      const color = field[i][j] === '**' ? '#FFFCF0' : await stringToColor(field[i][j]);\n      row.push(\n        <div\n          key={`${i}-${j}`}\n          style={{\n            width: boxSize,\n            height: boxSize,\n            backgroundColor: color,\n            padding: boxSize,\n            marginRight: '0em',\n            border: '1px solid #282726',\n            display: 'inline-block',\n          }}\n        />\n      );\n    }\n    visualizedField.push(<div key={i} style={{lineHeight: '0em'}}>{row}</div>);\n  }\n  return visualizedField;\n};\n\n// Create initial field when component mounts\nuseEffect(() => {\n  const initialField = createField(width, height);\n  visualizeField(initialField, width, height).then((visualized) => setField(visualized));\n}, []);\n\nuseEffect(() => {\n  console.log(\"Processing changed: \",processing)\n}, [processing]);\n\nconst handleWidthChange = (e) => {\n  setWidth(parseInt(e.target.value));\n};\n\nconst handleHeightChange = (e) => {\n  setHeight(parseInt(e.target.value));\n};\n\nconst handleNumBoxesChange = (e) => {\n  setNumBoxes(parseInt(e.target.value));\n};\n\nconst handleMinSizeChange = (e) => {\n  setMinSize(parseInt(e.target.value));\n};\n\nconst handleMaxSizeChange = (e) => {\n  setMaxSize(parseInt(e.target.value));\n};\n\nfunction getBoxOptions(minSize, maxSize, width, height) {\n  const options = new Set();\n  for (let i = minSize; i <= maxSize; i++) {\n    for (let j = minSize; j <= maxSize; j++) {\n      if (j <= height && i <= width) {\n        options.add([i, j, i * j].toString());\n        options.add([j, i, i * j].toString());\n      }\n    }\n  }\n\n  return Array.from(options).sort((a, b) => b[2] - a[2]);\n}\n\nfunction findSequenceOfLength(number, numbers, length, boxOptions) {\n  /*const nums = [];\n\n  for (let i = 0; i < boxOptions.length; i++) {\n    const size = boxOptions[i].split(\",\")[2];\n\n    if (numbers.includes(size)) {\n      nums.push(size);\n    }\n  }*/\n\n  const nums = numbers;\n\n  shuffle(nums);\n\n  let foundSequence = [];\n\n  function dfs(target, path) {\n    if (target === 0 && path.length === length) {\n      foundSequence = [...path];\n      return;\n    }\n\n    for (const num of nums) {\n      if (num <= target) {\n        path.push(num);\n        dfs(target - num, path);\n        path.pop();\n      }\n    }\n  }\n\n  dfs(number, []);\n\n  return foundSequence;\n}\n\nfunction findSequenceOfLengthBest(number, numbers, length, boxOptions) {\n  const nums = [];\n\n  for (let i = 0; i < boxOptions.length; i++) {\n    const size = boxOptions[i].split(\",\")[2];\n\n    if (numbers.includes(size)) {\n      nums.push(size);\n    }\n  }\n\n  shuffle(nums);\n\n  console.log(\"Nums: \",nums)\n\n  const dp = Array.from({ length: length + 1 }, () => Array(number + 1).fill(null));\n\n  try {\n    dp[0][0] = [];\n  } catch (e) {\n    return [];\n  }\n\n  for (let i = 1; i <= length; i++) {\n    for (let j = 0; j <= number; j++) {\n      for (const num of nums) {\n        if (j - num >= 0 && dp[i - 1][j - num] !== null) {\n          if (dp[i][j] === null || dp[i][j].length < i) {\n            const nextSequence = dp[i - 1][j - num].concat([num]);\n            if (!hasRepetition(nextSequence) || i >= length * 0.8) {\n              dp[i][j] = nextSequence;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return dp[length][number] !== null ? dp[length][number] : [];\n}\n\nfunction generateSequence(targetSum, arr, length) {\n  const result = [];\n\n  function dfs(currentSum, path) {\n    if (currentSum === targetSum && path.length === length) {\n      result.push([...path]);\n      return;\n    }\n\n    for (let i = 0; i < arr.length; i++) {\n      if (currentSum + arr[i] <= targetSum) {\n        path.push(arr[i]);\n        dfs(currentSum + arr[i], path);\n        path.pop();\n      }\n    }\n  }\n\n  dfs(0, []);\n\n  return result;\n}\n\n// Check if there are repetitions in the sequence\nfunction hasRepetition(sequence) {\n  for (let i = 1; i < sequence.length; i++) {\n    if (sequence[i] === sequence[i - 1]) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Helper function to shuffle an array\nfunction shuffle(array) {\n  let currentIndex = array.length, randomIndex;\n  while (currentIndex !== 0) {\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex--;\n\n    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];\n  }\n}\n\nfunction bentoIsFilledAppropriately(field, numBoxesSoFar, numBoxes) {\n  for (let row of field) {\n      for (let element of row) {\n          if (element === \"**\") {\n              return false;\n          }\n      }\n  }\n\n  console.log(\"Bento filled? \",numBoxesSoFar === numBoxes,numBoxesSoFar,numBoxes);\n\n  return numBoxesSoFar === numBoxes;\n}\n\nfunction storeForbiddenPath(forbiddenPathsDict, path, position, boxOption) {\n  if (forbiddenPathsDict[path]) {\n      if (!forbiddenPathsDict[path].includes(`${boxOption},${position}`)) {\n          forbiddenPathsDict[path].push(`${boxOption},${position}`);\n      }\n  } else {\n      forbiddenPathsDict[path] = [`${boxOption},${position}`];\n  }\n}\n\nfunction retrieveForbiddenPaths(forbiddenPathsDict, basePath) {\n    return forbiddenPathsDict[basePath] || [];\n}\n\nfunction getBoxOptionsFromSize(minSize, maxSize, size, width, height) {\n  const boxOptions = getBoxOptions(minSize, maxSize, width, height);\n  console.log(\"Box ops: \",boxOptions, \" size: \",size)\n  return boxOptions.filter(x => x.split(\",\")[2] === size);\n}\n\nfunction findCandidateIndices(field, boxOptionString) {\n  const boxOption = boxOptionString.split(\",\");\n  const boxWidth = parseInt(boxOption[0]);\n  const boxHeight = parseInt(boxOption[1]);\n\n  const indices = [];\n\n  const rows = field.length;\n  const cols = rows > 0 ? field[0].length : 0;\n\n  for (let i = 0; i < rows - boxHeight + 1; i++) {\n      for (let j = 0; j < cols - boxWidth + 1; j++) {\n          const subArr = field.slice(i, i + boxHeight).map(row => row.slice(j, j + boxWidth));\n          const isAllEmpty = subArr.every(row => row.every(elem => elem === \"**\"));\n          if (isAllEmpty) {\n              indices.push([i, j]);\n          }\n      }\n  }\n\n  return indices;\n}\n\nfunction augmentWithBox(field, index, boxOptionString, newChar) {\n  console.log(\"Augmentation time!!! \", index)\n  const fieldCopy = field.map(row => [...row]); // Deep copy of the field\n\n  const boxOption = boxOptionString.split(\",\")\n  const boxWidth = parseInt(boxOption[0]);\n  const boxHeight = parseInt(boxOption[1]);\n\n  const [x, y] = index;\n  for (let i = x; i < x + boxHeight; i++) {\n      for (let j = y; j < y + boxWidth; j++) {\n          console.log(\"Augmentation time!!!XXX\")\n          fieldCopy[i][j] = `*${newChar}`;\n      }\n  }\n\n  return fieldCopy;\n}\n\nonmessage = function (e) {\n  // Receive the data sent from the main thread\n  const { width, height, numBoxes, minSize, maxSize } = e.data;\n\n  let field = createField(width, height);\n\n  const boxOptions = getBoxOptions(minSize, maxSize, width, height);\n\n  const boxSizes = boxOptions.map((x) => x.split(\",\")[2]);\n\n  console.log(\"Box options: \",boxOptions);\n  console.log(\"Box sizes: \",boxSizes);\n\n  let theSequence = findSequenceOfLengthBest(width * height, boxSizes, numBoxes, boxOptions);\n  //let theSequence = generateSequence(width * height, boxSizes, numBoxes);\n  //shuffle(theSequence);\n  theSequence.sort((a, b) => b - a);\n\n  setSequence(theSequence.toString());\n\n  let prevPrevState = _.cloneDeep(field);\n  let prevState = _.cloneDeep(field);\n\n  let prevPrevNumBoxes = 0;\n  let prevNumBoxes = 0;\n  const forbiddenPathsDict = {};\n  let runNumber = 0;\n\n  let numBoxesSoFar = 0\n  let currentPath = []\n\n  if(theSequence.length > 0){\n    while (!bentoIsFilledAppropriately(field, numBoxesSoFar, numBoxes)) {\n      const relevantBoxSize = theSequence[numBoxesSoFar];\n      const relevantBoxOptions = getBoxOptionsFromSize(minSize, maxSize, relevantBoxSize, width, height);\n\n      let newBoxCanBeAdded = false;\n      let newBoxOption = null;\n      let newBoxIndex = null;\n\n      console.log(\"relevantBoxSize: \",relevantBoxSize);\n      console.log(\"relevantBoxOptions: \",relevantBoxOptions);\n\n      for (const boxOption of relevantBoxOptions) {\n          const candidateIndices = findCandidateIndices(field, boxOption);\n          //console.log(\"candidateIndices: \",candidateIndices);\n          const validCandidateIndices = [];\n\n          for (const candidateIndex of candidateIndices) {\n              const pathStr = `${candidateIndex},${boxOption}`;\n              if (!retrieveForbiddenPaths(forbiddenPathsDict, String(currentPath)).includes(pathStr)) {\n                  //console.log(\"ValidCandidate: \",candidateIndex,boxOption)\n                  validCandidateIndices.push(candidateIndex);\n              }\n          }\n\n          if (validCandidateIndices.length > 0) {\n              newBoxCanBeAdded = true;\n              newBoxOption = boxOption;\n              const randomIndex = Math.floor(Math.random() * validCandidateIndices.length)\n              console.log(\"vc length: \",validCandidateIndices.length)\n              console.log(\"randomIndex: \",randomIndex)\n              newBoxIndex = validCandidateIndices[randomIndex];\n              /*\n              if (validCandidateIndices.some(index => index[0] === 0 && index[1] === 0)) {\n                newBoxIndex = [0, 0];\n              } else {\n                newBoxIndex = validCandidateIndices[Math.floor(Math.random() * validCandidateIndices.length)];\n              }*/\n              break;\n          }\n      }\n\n      if (newBoxCanBeAdded) {\n          prevPrevNumBoxes = prevNumBoxes;\n          prevPrevState = _.cloneDeep(prevState);\n          prevNumBoxes = numBoxesSoFar;\n          prevState = _.cloneDeep(field);\n          const augmentedField = augmentWithBox(field, newBoxIndex, newBoxOption, numBoxesSoFar);\n          field = _.cloneDeep(augmentedField);\n          numBoxesSoFar++;\n\n          currentPath.push([newBoxOption, newBoxIndex]);\n      } else {\n          if (currentPath.length === 0) {\n              field = createField(width, height);\n\n              prevPrevNumBoxes = 0;\n              prevPrevState = _.cloneDeep(field);\n\n              prevNumBoxes = 0;\n              prevState = _.cloneDeep(field);\n\n              numBoxesSoFar = 0;\n          } else {\n              const [lastBoxPosition, lastBoxOption] = currentPath.pop();\n\n              storeForbiddenPath(forbiddenPathsDict, String(currentPath), lastBoxPosition, lastBoxOption);\n\n              if (currentPath.length === 0) {\n                  field = createField(width, height);\n\n                  prevPrevNumBoxes = 0;\n                  prevPrevState = _.cloneDeep(field);\n\n                  prevNumBoxes = 0;\n                  prevState = _.cloneDeep(field);\n\n                  numBoxesSoFar = 0;\n              } else {\n                  numBoxesSoFar = prevNumBoxes;\n                  field = _.cloneDeep(prevState);\n\n                  prevNumBoxes = prevPrevNumBoxes;\n                  prevState = _.cloneDeep(prevPrevState);\n              }\n          }\n      }\n\n      runNumber++;\n\n      if (runNumber % 1 === 0) {\n          console.log(runNumber, numBoxesSoFar);\n          console.log(\"path: \",currentPath);\n          console.log(\"numBoxesSoFar: \",numBoxesSoFar)\n      }\n\n      if (runNumber % 10 === 0) {\n          //visualizeField(field, width, height).then((visualized) => setField(visualized));\n      }\n\n      if (runNumber % 10000 === 0) {\n          break;\n      }\n\n\n      if (prevNumBoxes === prevPrevNumBoxes && prevNumBoxes === numBoxesSoFar) {\n          theSequence = findSequenceOfLengthBest(width * height, boxOptions.map(x => x.split(\",\")[2]), numBoxes, boxOptions);\n          //let theSequence = generateSequence(width * height, boxSizes, numBoxes);\n          theSequence.sort((a, b) => b - a);\n\n          setSequence(theSequence.toString())\n\n          field = createField(width, height);\n\n          prevPrevNumBoxes = 0;\n          prevPrevState = _.cloneDeep(field);\n\n          prevNumBoxes = 0;\n          prevState = _.cloneDeep(field);\n\n          numBoxesSoFar = 0;\n          currentPath = [];\n      }\n    }\n\n    //visualizeField(field, width, height).then((visualized) => setField(visualized));\n\n  }\n\n  \n  // Post the result back to the main thread\n  postMessage(field);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}